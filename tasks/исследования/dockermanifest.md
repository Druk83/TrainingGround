# Docker манифест проекта (dev + prod)

Этот документ задаёт правила: **как должны быть устроены Docker-конфигурации** и **как с ними работать** в проекте, чтобы:
- разработка была быстрой (правка кода ≠ rebuild образа),
- сборки были воспроизводимыми,
- production был минимальным и безопасным,
- диск не зарастал мусором (образы/кэш/тома).

---

## 1) Принципы (что считаем "хорошей" Docker-организацией)

### 1.1 Dev ≠ Prod
- **Dev-режим** оптимизируем под скорость итераций.
- **Prod-режим** оптимизируем под стабильность, безопасность, минимальный размер.

Нельзя пытаться одним и тем же compose/Dockerfile покрыть всё сразу без разделения режимов.

### 1.2 Сборка ≠ Запуск
- **Порядок запуска** описываем через `healthcheck` + ожидание готовности зависимостей.
- **Порядок сборки** обеспечиваем командами/скриптами (Makefile/CI), а не ожиданиями от `depends_on`.

### 1.3 Мелкая правка кода не должна требовать rebuild образа
- В dev используем **bind mounts** (монтирование исходников).
- В dev используем **watch/reload** (nodemon, cargo-watch, uvicorn --reload и т.п.).
- Rebuild делаем только при изменениях зависимостей или базового окружения.

### 1.4 Повторяемость (reproducible builds)
- Фиксируем версии зависимостей (lock-файлы).
- Базовые образы закрепляем (по tag/желательно digest).
- Конфигурация берётся из env/файлов, а не "магии в контейнере".

### 1.5 Кросс-платформенность
- Конфигурация работает на Linux, macOS, Windows без изменений.
- .gitattributes нормализует line endings (eol=lf) для всех текстовых файлов.
- Пути всегда используют forward slash (/).
- Volume mounts с опцией :cached для macOS/Windows (performance).

---

## 2) Структура Docker-конфигураций

### 2.1 Compose файлы
Рекомендуемая схема:
- `docker-compose.base.yml` — общие сервисы и сети (ядро).
- `docker-compose.dev.yml` — dev-override (mounts, debug, ports, watch).
- `docker-compose.prod.yml` — prod-override (минимум портов, без mounts, усиленная безопасность).
- опционально: `docker-compose.test.yml` — тестовое окружение (изолированное, быстрое).

**Правило:** base описывает "что это за сервисы", override описывает "как именно мы их запускаем в данном режиме".

### 2.2 Profiles (по необходимости)
Используйте `profiles`, чтобы не тащить всё сразу:
- `monitoring`, `devtools`, `ml`, `debug`, `ci` и т.д.

### 2.3 Обязательные файлы
- `.gitattributes` — нормализация line endings
- `.gitignore` — содержит `.env`, но НЕ `.env.example`
- `.env.example` — в Git, идентичен по структуре `.env`
- `.dockerignore` — рядом с каждым Dockerfile
- `Makefile` или task runner — стандартизированные команды

---

## 3) Dockerfile: как писать, чтобы было быстро и правильно

### 3.1 Multi-stage
Должны быть как минимум:
- `builder` stage — сборка/компиляция/установка зависимостей
- `runtime` stage — минимальный запуск

Dev-стейдж допускается отдельно:
- `dev` stage — инструменты разработки, reload/watch, отладка

### 3.2 Кэш-слои: зависимости отдельно от кода
Правильная последовательность:
1) копируем файлы зависимостей (`package-lock.json`, `Cargo.lock`, `requirements.txt`, `pyproject.toml`)
2) ставим зависимости
3) копируем исходники
4) собираем

**Цель:** изменение одного файла в `src/` не должно инвалидировать слой зависимостей.

### 3.3 Build cache
Где возможно — используем BuildKit и cache mounts для ускорения:
- pip cache
- cargo registry/target
- npm/yarn/pnpm store

### 3.4 Запреты
- Не копировать исходный код в development stage
- Не использовать :latest для базовых образов
- Не копировать .env или secrets файлы в образ
- Не устанавливать избыточные системные пакеты

---

## 4) Конфигурация и секреты

### 4.1 12-factor подход
- Конфигурация только через env / конфиг-файлы.
- Один и тот же образ должен запускаться в разных окружениях с разной конфигурацией.

### 4.2 Секреты
- Не хранить секреты в репозитории.
- Не передавать секреты в командной строке контейнера (видно в `inspect`).
- В prod: предпочтительно file-based secrets (Docker secrets / volume-mounted secret files).
- Минимум: `.env` вне git + строгие права доступа.

### 4.3 Единый контракт переменных окружения
Имена env-переменных должны быть одинаковыми в dev/prod/test.
Если нужны разные значения — меняем значения, не ключи.

---

## 5) Сети, порты и безопасность

### 5.1 Порты
- В dev публикуем порты наружу для удобства.
- В prod публикуем только то, что реально нужно пользователям (обычно один reverse-proxy).
- Базы/очереди/мониторинг в prod не должны быть открыты наружу без строгой необходимости.

### 5.2 Сети
- Разделяйте сети: `public` (входящий трафик) и `internal` (межсервисное).
- Для внутренних сервисов достаточно `expose`, а не `ports`.

### 5.3 Пользователь и права
- В runtime контейнере желательно работать не под root.
- Файлы с ключами/сертификатами/секретами — с минимальными правами и предсказуемой схемой доставки.

---

## 6) Данные и тома

### 6.1 Разделяйте "данные" и "кэш"
- Данные БД/хранилищ — в устойчивых volume'ах.
- Build/SDK кэши (cargo/pip/node) — отдельно, чтобы ускорять dev, но не путать с данными.

### 6.2 Не ломайте права на read-only mounts
Если файл монтируется как read-only, контейнер не должен пытаться менять его права/владельца.
Если нужны права — копируйте внутрь контейнера в writable путь на старте.

### 6.3 Named volumes для persistence
- Dependencies используют named volumes (переживают docker-compose down)
- Исходный код монтируется как bind mount с :cached на macOS/Windows

---

## 7) Healthchecks и готовность сервисов

### 7.1 Всегда определяйте healthcheck для критичных зависимостей
БД, очередь, кэш, vector store, секрет-хранилище — должны иметь healthcheck.

### 7.2 Запуск приложений должен ждать готовности зависимостей
Используйте:
- `healthcheck` + ожидание
- либо `wait-for-it`, `dockerize`, встроенный retry/backoff в приложении

---

## 8) Ресурсы и лимиты

### 8.1 Dev
В dev лимиты обычно мягкие, чтобы не мешать отладке.

### 8.2 Prod
В prod задавайте:
- лимиты CPU/Memory
- рестарты
- политики логов (ротация)

---

## 9) Логи и наблюдаемость

### 9.1 Логи
- Логи должны уходить в stdout/stderr, без записи в файлы внутри контейнера (если это не специально).
- Для prod — драйвер логов/агент/централизация (ELK/Loki/Vector/Fluent Bit и т.д.).

### 9.2 Мониторинг
- Мониторинг подключается профилем/override-файлом.
- В prod доступ к мониторингу защищён (VPN/Auth/ACL) и обычно не открыт наружу "как есть".

---

## 10) Рабочий процесс (Developer UX)

### 10.1 Команды должны быть стандартизированы
Проект должен иметь единые команды (Makefile/Taskfile/npm scripts):
- `make dev` — поднять dev окружение
- `make prod` — поднять prod конфигурацию
- `make test` — поднять тестовую инфраструктуру и прогнать тесты
- `make logs` — смотреть логи
- `make ps` — статус
- `make down` — выключить окружение

### 10.2 Точечная сборка сервисов
Команды для сборки/перезапуска только одного сервиса должны быть простыми:
- build one
- restart one
- run shell inside

### 10.3 Ритм разработки
Типичный день:
- Утро: `make dev` (один раз)
- День: редактирование кода (hot reload, без docker команд)
- Добавил dependency: `make rebuild`
- Вечер: `make down`

**Антипаттерн:** если набираешь `docker build` чаще раза в час — что-то не так.

---

## 11) Управление "мусором" (образы, кэш, тома)

### 11.1 Это часть процесса, а не ручная боль
В проекте должны быть команды очистки:

- **легкая очистка** (dangling images)
- **очистка билд-кэша**
- **полная очистка** (осторожно)
- **очистка конкретного проекта** (down + remove-orphans + rmi local)

### 11.2 Регулярность
Рекомендуется:
- лёгкая очистка — ежедневно/по необходимости
- билд-кэш — когда заметно разросся
- полная очистка — после экспериментов/веток/CI-гонок

---

## 12) Checklist: минимальный стандарт качества

### Dev must-have
- [ ] bind mounts для исходников
- [ ] watch/reload (без rebuild)
- [ ] кэш зависимостей (pip/cargo/node)
- [ ] быстрые команды (make/dev scripts)
- [ ] .gitattributes с eol=lf
- [ ] volume mounts с :cached для macOS/Windows

### Prod must-have
- [ ] multi-stage Dockerfile (runtime минимальный)
- [ ] секреты не в командной строке и не в git
- [ ] закрытые внутренние порты
- [ ] healthchecks/ожидание готовности
- [ ] лимиты ресурсов и политика рестарта
- [ ] централизованные логи/наблюдаемость (опционально)

### Hygiene must-have
- [ ] команды очистки docker мусора в проекте
- [ ] отсутствие `container_name` (по возможности) для масштабирования/параллельных окружений
- [ ] единый контракт env для всех окружений
- [ ] .dockerignore рядом с каждым Dockerfile

---

## 13) Правила для MCP-агента при работе с Docker

### 13.1 При создании новой Docker конфигурации
- Создать multi-stage Dockerfile (минимум: development, production)
- Убедиться что development stage НЕ копирует исходный код
- Создать .dockerignore с исключением node_modules, target, .git, .env
- Создать .gitattributes с `* text=auto eol=lf`
- Настроить bind mounts в docker-compose для dev
- Исключить dependencies из volume mounts (anonymous volume)
- Использовать ${VAR} для всех значений в compose
- Создать .env.example со всеми переменными

### 13.2 При проверке существующей конфигурации
Проверить наличие:
- [ ] Multi-stage build в Dockerfile
- [ ] Development stage без COPY исходников
- [ ] Volume mounts для source code в docker-compose.dev.yml
- [ ] .dockerignore файл
- [ ] .gitattributes файл
- [ ] ${VAR} вместо хардкода в compose
- [ ] BuildKit cache mounts где применимо
- [ ] Правильный порядок слоёв (deps → code)

### 13.3 При изменении конфигурации
Правила:
- НЕ добавляй COPY исходного кода в development stage
- НЕ создавай отдельные Dockerfile.dev и Dockerfile.prod
- НЕ используй хардкод значений в docker-compose
- НЕ монтируй dependencies как bind mount
- Сохраняй порядок инструкций для оптимизации кэша
- Используй YAML anchors для устранения дублирования
- Добавляй комментарии для неочевидных решений

### 13.4 Частые ошибки для исправления
- `COPY . .` в development stage → удалить
- Хардкод в docker-compose → заменить на ${VAR}
- Отсутствие .dockerignore → создать
- `:latest` в базовом образе → указать версию
- Отсутствие .gitattributes → создать
- Дублирующиеся блоки в compose → использовать YAML anchors
- Dependencies в bind mount → использовать named volume

### 13.5 Диагностические вопросы
**Если требуется пересборка при изменении кода:**
- Копируется ли source code в development stage? → убрать COPY, добавить volume mount

**Если медленная работа на macOS/Windows:**
- Используется ли :cached для volume mounts? → добавить
- Монтируются ли dependencies? → использовать named volumes

**Если dependencies устанавливаются каждый раз:**
- Правильный ли порядок в Dockerfile? → COPY deps → RUN install → COPY code

**Если shell скрипты не работают:**
- Есть ли .gitattributes? → создать с eol=lf

---

## 14) Определение "готово"
Docker-конфигурация считается правильно организованной, если:
- разработчик может править код и сразу видеть результат без пересборки,
- сборка на CI воспроизводима и предсказуема,
- production минимален и не раскрывает внутренние сервисы,
- очистка мусора — штатная команда проекта, а не аварийная мера,
- конфигурация работает на всех платформах (Linux/macOS/Windows) без изменений,
- MCP-агент может автоматически проверить и исправить типичные ошибки.