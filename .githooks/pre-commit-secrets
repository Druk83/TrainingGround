#!/bin/bash
# Pre-commit hook для проверки секретов
# Проверяет что JWT_SECRET и другие секреты не хардкодены в коде

set -e

echo "[SECURITY] Checking for hardcoded secrets..."

# Получить список staged файлов
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo "[INFO] No files staged, skipping secrets check"
    exit 0
fi

# Цвета для вывода
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

ERRORS_FOUND=0

# ============================================
# 1. Проверка JWT_SECRET в коде
# ============================================
echo "[INFO] Checking for hardcoded JWT_SECRET..."

# Паттерны для поиска хардкоденного JWT_SECRET
JWT_PATTERNS=(
    'JWT_SECRET\s*=\s*["\047][^"\047$]{10,}["\047]'  # JWT_SECRET = "hardcoded_value"
    'jwt_secret:\s*["\047][^"\047$]{10,}["\047]'      # jwt_secret: "hardcoded_value"
    'jwtSecret\s*=\s*["\047][^"\047$]{10,}["\047]'    # jwtSecret = "hardcoded_value"
    'secret:\s*["\047][a-zA-Z0-9+/]{32,}["\047]'      # secret: "base64_encoded_secret"
)

for pattern in "${JWT_PATTERNS[@]}"; do
    for file in $STAGED_FILES; do
        # Пропускаем .env файлы (они проверяются отдельно)
        if [[ "$file" =~ \.env || "$file" =~ \.env\. ]]; then
            continue
        fi

        # Пропускаем бинарные файлы, изображения, node_modules, документацию, git hooks
        if [[ "$file" =~ \.(png|jpg|jpeg|gif|svg|ico|woff|woff2|ttf|eot|md)$ ]] || \
           [[ "$file" =~ node_modules/ ]] || \
           [[ "$file" =~ target/ ]] || \
           [[ "$file" =~ ^\.githooks/ ]] || \
           [[ "$file" =~ ^docs/ ]]; then
            continue
        fi

        # Проверяем существует ли файл
        if [ -f "$file" ]; then
            matches=$(git diff --cached "$file" | grep -E "^\+" | grep -vE "^\+\+\+" | grep -iE "$pattern" || true)
            if [ -n "$matches" ]; then
                echo -e "${RED}[ERROR] Hardcoded JWT_SECRET found in: $file${NC}"
                echo "$matches"
                ERRORS_FOUND=$((ERRORS_FOUND + 1))
            fi
        fi
    done
done

# ============================================
# 2. Проверка других секретов (пароли, токены, API keys)
# ============================================
echo "[INFO] Checking for other hardcoded secrets..."

# Паттерны для поиска различных секретов
SECRET_PATTERNS=(
    # API Keys и токены
    'api[_-]?key\s*[=:]\s*["\047][a-zA-Z0-9_\-]{20,}["\047]'
    'apikey\s*[=:]\s*["\047][a-zA-Z0-9_\-]{20,}["\047]'
    'access[_-]?token\s*[=:]\s*["\047][a-zA-Z0-9_\-\.]{20,}["\047]'
    'secret[_-]?key\s*[=:]\s*["\047][a-zA-Z0-9_\-]{20,}["\047]'

    # AWS credentials
    'aws[_-]?access[_-]?key[_-]?id\s*[=:]\s*["\047]AKIA[A-Z0-9]{16}["\047]'
    'aws[_-]?secret[_-]?access[_-]?key\s*[=:]\s*["\047][A-Za-z0-9/+=]{40}["\047]'

    # Private keys (начало) - экранируем дефисы
    'BEGIN.*(RSA )?PRIVATE KEY'

    # Database credentials (только явные пароли, не env vars)
    'password\s*[=:]\s*["\047][^\"\047$\{]{8,}["\047]'
    'db[_-]?password\s*[=:]\s*["\047][^\"\047$\{]{8,}["\047]'
    'mongodb[_-]?password\s*[=:]\s*["\047][^\"\047$\{]{8,}["\047]'

    # Generic secrets (минимум 32 символа base64)
    'secret\s*[=:]\s*["\047][A-Za-z0-9+/=]{32,}["\047]'
)

for pattern in "${SECRET_PATTERNS[@]}"; do
    for file in $STAGED_FILES; do
        # Пропускаем .env, бинарники, node_modules, git hooks, документацию
        if [[ "$file" =~ \.env || "$file" =~ \.env\. ]] || \
           [[ "$file" =~ \.(png|jpg|jpeg|gif|svg|ico|woff|woff2|ttf|eot|md)$ ]] || \
           [[ "$file" =~ node_modules/ ]] || \
           [[ "$file" =~ target/ ]] || \
           [[ "$file" =~ ^\.githooks/ ]] || \
           [[ "$file" =~ ^docs/ ]]; then
            continue
        fi

        if [ -f "$file" ]; then
            matches=$(git diff --cached "$file" | grep -E "^\+" | grep -vE "^\+\+\+" | grep -iE "$pattern" || true)
            if [ -n "$matches" ]; then
                echo -e "${YELLOW}[WARNING] Potential secret found in: $file${NC}"
                echo "$matches"
                # Не увеличиваем ERRORS_FOUND для warnings, только показываем
            fi
        fi
    done
done

# ============================================
# 3. Проверка .env файлов на production secrets
# ============================================
echo "[INFO] Checking .env files for production secrets..."

for file in $STAGED_FILES; do
    # Проверяем только .env файлы (но не .env.example или .env.prod.example)
    # Разрешаем: .env.example, .env.prod.example, .env.production.example
    # Блокируем: .env, .env.prod, .env.production, .env.local
    if [[ ! "$file" =~ \.example$ ]]; then
        if [[ "$file" =~ ^\.env$ ]] || [[ "$file" =~ \.env\.prod$ ]] || [[ "$file" =~ \.env\.production$ ]] || [[ "$file" =~ \.env\.local ]]; then
            echo -e "${RED}[ERROR] Attempting to commit production .env file: $file${NC}"
            echo "Production .env files should NEVER be committed!"
            echo "These files are in .gitignore and should stay out of git."
            echo ""
            echo "To fix, run:"
            echo "  git reset HEAD $file"
            ERRORS_FOUND=$((ERRORS_FOUND + 1))
        fi
    fi

    # Проверяем .env.example на реальные секреты
    if [[ "$file" =~ \.env\.example$ ]]; then
        if [ -f "$file" ]; then
            # Проверяем что JWT_SECRET это плейсхолдер
            jwt_secret_value=$(git diff --cached "$file" | grep -E "^\+" | grep -E "JWT_SECRET\s*=" | sed 's/.*JWT_SECRET\s*=\s*//' || true)
            if [ -n "$jwt_secret_value" ]; then
                # Проверяем что это НЕ реальный секрет (должен быть placeholder)
                if ! echo "$jwt_secret_value" | grep -qiE "(change|placeholder|example|your_|<|>|\.\.\.)"; then
                    # Проверяем длину - если >30 символов base64, вероятно реальный секрет
                    clean_value=$(echo "$jwt_secret_value" | tr -d '"' | tr -d "'" | xargs)
                    if [ ${#clean_value} -ge 30 ]; then
                        echo -e "${RED}[ERROR] Real JWT_SECRET found in .env.example: $file${NC}"
                        echo "JWT_SECRET in .env.example should be a placeholder like:"
                        echo '  JWT_SECRET=changeme_generate_with_openssl_rand_base64_32'
                        echo ""
                        echo "Current value appears to be a real secret (length: ${#clean_value})"
                        ERRORS_FOUND=$((ERRORS_FOUND + 1))
                    fi
                fi
            fi

            # Проверяем VAULT_ROOT_TOKEN
            vault_token=$(git diff --cached "$file" | grep -E "^\+" | grep -E "VAULT_ROOT_TOKEN\s*=" | sed 's/.*VAULT_ROOT_TOKEN\s*=\s*//' || true)
            if [ -n "$vault_token" ]; then
                clean_token=$(echo "$vault_token" | tr -d '"' | tr -d "'" | xargs)
                # Проверяем что это dev-root-token или placeholder
                if [[ "$clean_token" != "dev-root-token" ]] && ! echo "$clean_token" | grep -qiE "(change|placeholder|example|your_|<|>)"; then
                    if [ ${#clean_token} -ge 20 ]; then
                        echo -e "${RED}[ERROR] Real VAULT_ROOT_TOKEN found in .env.example: $file${NC}"
                        echo "Use 'dev-root-token' for development or a placeholder"
                        ERRORS_FOUND=$((ERRORS_FOUND + 1))
                    fi
                fi
            fi

            # Проверяем пароли MongoDB
            mongo_password=$(git diff --cached "$file" | grep -E "^\+" | grep -iE "MONGO.*PASSWORD\s*=" | sed 's/.*PASSWORD\s*=\s*//' || true)
            if [ -n "$mongo_password" ]; then
                clean_pass=$(echo "$mongo_password" | tr -d '"' | tr -d "'" | xargs)
                if ! echo "$clean_pass" | grep -qiE "(change|placeholder|example|your_|<|>|\.\.\.)"; then
                    if [ ${#clean_pass} -ge 12 ]; then
                        echo -e "${YELLOW}[WARNING] Suspicious MongoDB password in .env.example: $file${NC}"
                        echo "Ensure this is a placeholder, not a real production password"
                    fi
                fi
            fi
        fi
    fi
done

# ============================================
# 4. Проверка на случайные credential files
# ============================================
echo "[INFO] Checking for credential files..."

CREDENTIAL_FILE_NAMES=(
    "credentials.json"
    "service-account.json"
    "admin-superuser.json"
    ".password"
    ".secret"
)

CREDENTIAL_EXTENSIONS=(
    ".pem"
    ".key"
    ".p12"
    ".pfx"
    ".jks"
    ".keystore"
)

for file in $STAGED_FILES; do
    # Пропускаем docs и scripts
    if [[ "$file" =~ ^docs/ ]] || [[ "$file" =~ ^scripts/ ]] || [[ "$file" =~ \.example$ ]]; then
        continue
    fi

    # Получаем basename и расширение
    basename=$(basename "$file")
    extension="${basename##*.}"

    # Проверяем точное совпадение имени файла
    for cred_name in "${CREDENTIAL_FILE_NAMES[@]}"; do
        if [[ "$basename" == "$cred_name" ]]; then
            echo -e "${RED}[ERROR] Attempting to commit credential file: $file${NC}"
            echo "Credential files should be in .gitignore"
            echo ""
            echo "To fix, run:"
            echo "  git reset HEAD $file"
            ERRORS_FOUND=$((ERRORS_FOUND + 1))
            break
        fi
    done

    # Проверяем расширение файла (если есть точка в имени)
    if [[ "$basename" == *.* ]]; then
        for ext in "${CREDENTIAL_EXTENSIONS[@]}"; do
            if [[ ".$extension" == "$ext" ]]; then
                echo -e "${RED}[ERROR] Attempting to commit credential file with extension $ext: $file${NC}"
                echo "Credential files should be in .gitignore"
                echo ""
                echo "To fix, run:"
                echo "  git reset HEAD $file"
                ERRORS_FOUND=$((ERRORS_FOUND + 1))
                break
            fi
        done
    fi
done

# ============================================
# Итоговый результат
# ============================================
echo ""
if [ $ERRORS_FOUND -gt 0 ]; then
    echo -e "${RED}================================${NC}"
    echo -e "${RED}SECRETS CHECK FAILED!${NC}"
    echo -e "${RED}Found $ERRORS_FOUND security issue(s)${NC}"
    echo -e "${RED}================================${NC}"
    echo ""
    echo "Please fix the issues above before committing."
    echo ""
    echo "Common fixes:"
    echo "  1. Use environment variables instead: process.env.JWT_SECRET, std::env::var(\"JWT_SECRET\")"
    echo "  2. Remove real secrets from .env.example (use placeholders)"
    echo "  3. Unstage sensitive files: git reset HEAD <file>"
    echo "  4. Add sensitive files to .gitignore"
    echo ""
    exit 1
else
    echo -e "${GREEN}[SUCCESS] No hardcoded secrets detected${NC}"
    exit 0
fi
