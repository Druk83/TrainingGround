# Контроль контента и админские инструменты

Документ описывает, как новая админская рабочая группа (задача A6) управляет шаблонами, правилами, фич-флагами и пайплайном эмбеддингов. Используйте этот материал при модерации, массовом импорте или диагностике очереди `content:changes`.

## Жизненный цикл шаблона

Теперь шаблон проходит строгий путь `draft → ready → published → deprecated`:

- **draft** — первичное сохранение; видно только в админ-консоли. Шаблону присваивается уникальный `slug`, он привязывается к уровню/теме и автоматически проходит валидацию на дубликаты, «грязный» контент и PII (email + телефон по regex, черный список вроде `xxx`/`наркотик`).
- **ready** — модератор ставит статус, когда метаданные, примеры и ссылки удовлетворяют контрольным точкам качества. Допустимы только переходы `draft → ready`, `ready → published`, `published → deprecated`. Любая роль может вернуть шаблон в `draft` через `/admin/templates/{id}/revert`, указав причину — она сохраняется в `audit_log`.
- **published** — шаблон становится активным, сразу отправляется событие в stream `content:changes`, длину и последние события можно смотреть на `/admin/queue` (`XLEN`/`XREVRANGE`). Пайтон-пайплайн эмбеддингов слушает очередь и пересобирает векторы по версиям, так что обновления или откаты тоже создают события.
- **deprecated** — шаблон архивируется, но его можно вернуть в `draft` для прозрачности, он больше не участвует в генерации задач.

Все переходы логируются в `audit_log` с `actor_id`, `action`, `target`, а также опциональной `reason`. Консоль показывает статус и соответствующие записи аудита при открытии шаблона.

## Контроль качества и импорт

- **Уникальность** — система запрещает два шаблона с одинаковым `slug` внутри одного `level_id`.
- **PII** — текст проверяется до вставки/обновления на email и последовательности из 10+ цифр; при нарушении возвращается понятная ошибка и модератор может поправить контент.
- **Черные списки** — настраиваемые токены вроде `xxx`, `наркотик` или любые другие ругательства блокируются заранее.
- **Ссылки на источники** — каждый шаблон и причина отката должны ссылаться на проверенный документ в `source_refs`.
- **Линтинг правил** — скрипт импорта явно документирует метаданные правил и структуру примеров, чтобы соблюдалась лингвистическая точность (русский язык).

Используйте `scripts/import_templates.py` вместе с `infra/config/seed/admin_templates.json`, чтобы загрузить темы, уровни, правила и шаблоны из готовых наборов. Скрипт читает `.env` (или `MONGODB_URI`/`MONGODB_DATABASE`) и поддерживает флаг `--dry-run` для безопасной проверки.

## Пайплайн эмбеддингов и мониторинг

- Публикация шаблона (или обновление уже опубликованного) вызывает `XADD` в `CONTENT_STREAM_NAME` (по умолчанию `content:changes`). Очередь читается Python-сервисом объяснений, который пересобирает эмбеддинги Qdrant по версии шаблона.
- Новый эндпоинт `/admin/queue` возвращает длину очереди (`XLEN`) и последнюю пару `template_id/action`, чтобы модераторы видели рост бэклога и связывали его с метриками Redis/алертами (например, очередь > 100).
- CLI/воркеры уже следят за `content:changes` (`infra/scripts/changestream_bridge.py`, `python-generator/src/explanation_service`). Админ API просто дублирует эти события для ручных триггеров и статуса очереди.

## Фич-флаги

- Флаги живут в коллекции `feature_flags` и теперь переключаются через `/admin/feature-flags`. Каждое изменение сохраняет время (`updated_at`) и инвалидирует кеш Redis (`feature_flag_cache`).
- Флаги идентифицируются по `flag_name` (например, `enable_yandex_gpt`) и могут быть привязаны к ролям или группам. UI показывает текущий статус и позволяет переключать флаг одним кликом.

## Безопасность и доступы

- Только авторизованные пользователи с `role=admin` имеют доступ к `/admin/...`. Middleware `admin_guard_middleware` проверяет это на всех маршрутах.
- Все чувствительные операции (CRUD, откат, переключение флагов) попадают в аудит. Коллекция `audit_log` хранит `actor_role`, `actor_id`, `target_id`, название действия и причину (если есть).
- Критические действия (откаты, удаление, публикация) можно дополнительно привязать к SSO/OTP при включенном `ENABLE_SSO`; middleware уже учитывает `enable_sso` из конфигурации.
- При первом запуске API укажите файл супер‑юзера через `ADMIN_SEED_FILE` (по умолчанию `infra/config/seed/admin-superuser.json`). Секретный JSON содержит email/password/role, скрипт `scripts/generate_superuser_secret.py` генерирует его с безопасным паролем. Backend создаёт запись через `superuser_seed::bootstrap` с хешированием bcrypt (cost=12). Пароль никогда не хранится в plain-text, сам файл следует хранить в vault и передавать по защищённому каналу. Подробнее: [docs/deployment-security.md](./deployment-security.md)

## Что делать дальше

1. Откройте админ-консоль (`/admin`), фильтруйте шаблоны по теме/уровню/статусу, запускайте предпросмотр и следите за виджетом очереди эмбеддингов.
2. Прогоните `scripts/import_templates.py --dry-run`, чтобы проверить JSON, затем уберите `--dry-run` для реального импорта.
3. Следите за Redis Stream через `redis-cli XLEN content:changes` или API и сопоставляйте всплески с логами Python-генератора (`python-generator` service).
