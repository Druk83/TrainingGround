
# Обоснование выбора технологий

Документ фиксирует возможные технологические стеки для проекта «Русский язык: тренировочный полигон» и критерии, по которым они оцениваются. Цель — позволить команде выбрать оптимальный набор инструментов для MVP и дальнейшего развития.

## 1. Ключевые критерии
1. **Скорость вывода MVP.** Нужна возможность собрать веб-версию с таймером, баллами, подсказками и статистикой в течение 1–2 месяцев.
2. **Адаптивная генерация заданий.** Интеграция с YandexGPT и наличие fallback на локальные шаблоны.
3. **Расширяемость на PWA и терминал.** Общая бизнес-логика и API, многоразовая модель данных.
4. **Сопровождение и найм.** Доступность специалистов и открытая экосистема библиотек по обработке русского языка.
5. **Производительность и античит.** Обработка запросов <1 с, защита от массовых автоматических ответов.
6. **Стоимость инфраструктуры.** Возможность развертывания в облаках РФ и использовании managed-сервисов (PostgreSQL, объектное хранилище).

## 2. Кандидатные стеки

### 2.1 JavaScript/TypeScript-центричный (рекомендуемый для MVP)
- **Фронтенд:** React + Vite или Next.js, UI-библиотека (MUI/Tailwind) для быстрого прототипирования. PWA поддержка доступна из коробки.
- **Бэкенд:** NestJS (Node.js, TypeScript). Даёт строгую структуру модулей, DI и готовые guard'ы для античита и rate limiting.
- **API:** GraphQL или REST (Fastify/Express). WebSocket-канал для живых обновлений таймера/подсказок.
- **БД:** PostgreSQL (основные сущности — темы, шаблоны, попытки) + Redis для кэширования сессий и античита.
- **ИИ-сервис:** Отдельный Python-микросервис (FastAPI) для YandexGPT, чтобы использовать библиотеки обработки русского языка (pymorphy2, Natasha).
- **Терминал:** Node.js CLI (Commander.js) или обёртка над REST API.
- **Деплой:** Docker + Kubernetes/YaCloud Serverless Containers.

**Плюсы:** единый язык JS для фронта и бэкенда → высокая скорость разработки; богатая экосистема UI-компонентов и Web/PWA tooling; NestJS упрощает построение модульной архитектуры; PostgreSQL легко интегрируется через TypeORM/Prisma; наличие готовых решений античита (rate limiter, captcha).  
**Минусы:** ресурсоёмкость Node.js при CPU-интенсивных операциях, необходимость отдельного сервиса на Python для продвинутой лингвистики; высокий порог для разработчиков без опыта TypeScript/NestJS.

### 2.2 Python-ориентированный стек
- **Фронтенд:** React или Vue (через Vite) — остаётся JavaScript, но можно подключить Django Templates для админки.
- **Бэкенд:** FastAPI (асинхронный) или Django + DRF. Лёгкая интеграция с NLP-библиотеками, единый язык с ИИ-модулем.
- **API:** REST с OpenAPI-спецификацией; WebSocket через FastAPI/Django Channels.
- **БД:** PostgreSQL (SQLAlchemy, Django ORM) + Redis (Celery, rate limiting).
- **ИИ и генерация:** Встроено в FastAPI/Django, нет необходимости в отдельном микросервисе.
- **Терминал:** Click/Typer CLI на Python, переиспользует модели и проверки.
- **Деплой:** Docker + Gunicorn/Uvicorn, возможен сервер без Kubernetes (упрощённо для небольших команд).

**Плюсы:** богатые библиотеки для морфологического анализа и проверки правил русского языка; меньше переключений между языками; быстрый старт для команд с опытом Python.  
**Минусы:** меньше готовых решений для real-time и высоконагруженных сценариев, чем в JS/Golang; фронтенд всё равно на JS, поэтому нет полного одноязычия; Django может быть избыточным для лёгкого API, а FastAPI требует дисциплины в структуре проекта.

### 2.3 Высокопроизводительный/кросс-платформенный
- **Фронтенд:** SvelteKit или Flutter Web для облегчения клиента и унификации с мобильными приложениями.
- **Бэкенд:** Go (Gin/Fiber) для максимальной производительности и встроенной конкуренции (полезно для античита).
- **БД:** PostgreSQL + ClickHouse (анализ статистики и попыток).
- **ИИ:** Python-сервисы, взаимодействующие через gRPC/RabbitMQ.
- **Терминал:** Go CLI (Cobra) с возможностью офлайн-режима (встроенный SQLite и предзагруженные задания).
- **Деплой:** Kubernetes или serverless (Cloud Run/Yandex Serverless Functions) + CI/CD.

**Плюсы:** высокая производительность и низкое потребление ресурсов; легко масштабировать real-time проверки; Go-процессы надёжны для античита и аналитики; Flutter/Svelte позволяет ближе подойти к нативной скорости на мобильных устройствах.  
**Минусы:** более высокая стоимость входа (Go + Flutter команда); меньше готовых решений для образовательных интерфейсов; Flutter Web может быть тяжёлым для старых школьных устройств; требуется отдельный Python слой для NLP.

### 2.4 Низкокод/гибридное решение (для пилота в школах)
- **Фронтенд:** Webflow/Bubble + встраиваемые JS-виджеты для таймера и проверки.
- **Бэкенд:** Firebase/Firestore или Supabase (аутентификация, хранение данных).
- **Банк заданий:** Google Sheets/Airtable как источник контента, синхронизируемый скриптами.
- **ИИ:** YandexGPT через серверless функции (Cloud Functions).
- **Терминал:** отсутствует или реализуется как простая консоль, работающая с REST API Supabase.

**Плюсы:** максимально быстрый запуск пилота, минимум кода, дешёвая поддержка.  
**Минусы:** ограниченная гибкость (сложно реализовать античит, сложные правила баллов, офлайн-доступ); vendor lock-in; проблемы с производительностью при росте пользователей.

### 2.5 Минималистичный стек без фреймворков
- **Фронтенд:** чистый TypeScript + нативные Web Components и PWA-механика (Service Worker, manifest) без сторонних SPA-фреймворков; esbuild/Vite используется только как транспайлер. Роутинг/состояния реализуются вручную.
- **Бэкенд (игровая логика):** Rust с минимальными зависимостями (`hyper`, `tokio`). Отвечает за API таймера, начисление баллов, античит и хранение сессий в памяти.
- **Сервис генерации/ИИ:** Python на стандартной библиотеке (asyncio + `http.server`/`aiohttp` в нативном режиме), используемый только для YandexGPT, морфологических проверок и наполнения банка заданий.
- **Низкоуровневые модули:** критичные алгоритмы можно вынести в чистый C/Rust и подключать из обоих сервисов.
- **База знаний и данные:** MongoDB — единое постоянное хранилище (правила, шаблоны, попытки, агрегаты статистики, отчёты); Redis — оперативный кэш и лимиты; Qdrant — векторный индекс эмбеддингов для Retrieval-Augmented Generation.
- **Терминал:** лёгкий CLI на Rust или Python, работающий поверх REST API или локального SQLite-файла.

**Плюсы:** полный контроль над кодовой базой, отсутствие навязанных паттернов; высокое быстродействие Rust-сервиса, возможность тонко оптимизировать античит и таймеры; Python остаётся только там, где нужна NLP-экосистема; Mongo обеспечивает источник истины для контента, Redis закрывает оперативные задачи, а Qdrant отвечает за быстрый векторный поиск по базе знаний без тяжёлых фреймворков.  
**Минусы:** высокая стоимость поддержки (нужно самостоятельно проектировать роутинг, состояние, безопасность); больше ручной работы по доступности и локализации фронтенда; отсутствие готовой админки и DevTools, сложнее подключать новых разработчиков; распределённость логики между Rust/Python/C усложняет отладку и CI/CD.

---

## Решение по выбору

- **Выбранный стек:** Используем вариант 2.5 — минималистичную конфигурацию без тяжёлых фреймворков. Фронтенд строится на чистом TypeScript и нативных Web Components с PWA-слоем (manifest + Service Worker); игровой API реализуется на Rust (hyper/tokio); генерация заданий и интеграция с YandexGPT выполняются Python-сервисом на стандартной библиотеке; MongoDB хранит шаблоны и историю попыток, Redis обслуживает сессии, таймеры и античит, Qdrant отвечает за векторный поиск.
- **База знаний:** Документное ядро (MongoDB) связывается с Qdrant; Python-сервис автоматически пересоздаёт эмбеддинги и выполняет RAG-запросы для генерации заданий/пояснений, что определяет выбор хранилищ и интеграцию между сервисами.
- **Причины выбора:** полный контроль над кодовой базой и зависимостями, возможность точечно оптимизировать критичные участки (таймер, подсчёт баллов, античит), гибкость при создании собственных инструментов проверки правил без ограничений фреймворков.
- **Организационные меры:** сразу закладываем ресурсы на внутренние библиотеки (роутинг, состояние, UI), общую схему данных между Rust и Python (JSON Schema/gRPC), CI/CD для смешанной кодовой базы и документацию для онбординга.
- **Масштабирование:** Rust-сервис масштабируется горизонтально, Python-модуль — отдельными воркерами для ИИ-задач; при росте аналитики можно добавить специализированные хранилища (ClickHouse) без смены базового подхода.
- **Альтернативы:** низкокод и фреймворочные решения откладываются, чтобы не дублировать инфраструктуру; допускается точечное заимствование идей из других вариантов (например, готовые PWA-компоненты), если они не нарушают принцип минимализма.
