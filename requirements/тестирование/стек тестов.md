# Стек тестов

Документ описывает стратегию тестирования проекта «Русский язык: тренировочный полигон». Содержит перечень уровней тестов, инструменты, порядок автоматизации и требования к окружению.

---

## 1. Уровни тестирования

| Уровень | Область | Цель |
|---------|---------|------|
| Unit | Frontend (TypeScript), Rust API, Python | Проверка единичных функций/компонентов: вычисление баллов, проверка ответов, подсказки, RAG-пайплайн. |
| API/Integration | Rust ↔ Mongo/Redis/Qdrant, Rust ↔ Python | Гарантия совместимости контрактов (OpenAPI, Explanation API), корректность транзакций и очередей. |
| E2E (UI) | PWA + backend | Эмуляция сценариев ученика/куратора/админа через браузер. |
| Performance | Rust API, Redis, Mongo, Python/Qdrant | Проверка SLA (latency, генерация подсказок, отчёты). |
| Security/Anticheat | Авторизация JWT, античит-правила | Проверка ролей, ограничений подсказок, блокировок. |
| Regression | Сборка релиза | Проверка критических бизнес-сценариев перед деплоем. |

---

## 2. Фронтенд (PWA)

- **Unit tests:** Vitest + @web/test-runner (компоненты, сервисы состояния, валидаторы ввода).  
- **E2E:** Playwright / WebdriverIO, запуск в CI против docker-compose окружения (Rust + Python). Сценарии: прохождение урока, подсказки, просмотр статистики, работа офлайн (Service Worker).  
- **Static analysis:** ESLint + TypeScript `--noEmit`, проверка accessibility (axe) и PWA-метрик (Lighthouse).  
- **Mock API:** используется сгенерированный OpenAPI клиент (TypeScript). Для офлайн/таймаутов есть сценарии деградации.

---

## 3. Rust API

- **Unit:** `cargo test` (бизнес-логика: Scoring Engine, античит, таймеры).  
- **Integration:** тесты с поднятым Mongo/Redis/Qdrant (используется docker-compose profile `test`). Проверяется: транзакции Mongo + Redis, сериализация Attempt Record, покупка подсказок (Lua).  
- **Contract tests:** JSON Schema/OpenAPI → проверки соответствия ответов (используется `schemars` + `openapi-diff`).  
- **Performance:** `k6` или `vegeta` (500 rps, пиковые нагрузки, SLA 200 мс).  
- **Security:** проверка JWT/RBAC (negative cases), fuzzing ответов (cargo-fuzz) для парсеров.

---

## 4. Python-сервис (генерация/объяснения)

- **Unit:** `pytest` + `mypy` + `ruff` (векторизация, морфология, генерация подсказок).  
- **Integration:** тесты Explanation API против локального Qdrant и Redis Streams; проверка обработки ошибок YandexGPT (моки).  
- **Load:** измерение времени RAG (k=5), SLA 2 сек при параллельных запросах (20 qps).  
- **Data validation:** тесты на банке шаблонов (правила coverage, отсутствия пустых эмбеддингов).

---

## 5. Qdrant / MongoDB / Redis

- **Schema tests:** миграции (Mongo) проверяются скриптом `infra/tests/mongo_schema.test.js` (создание индексов, наличие TTL).  
- **Qdrant:** проверка коллекций (размер вектора, payload schema) и snapshot restore.  
- **Redis:** тесты Lua-скриптов (hints purchase, scoring series) через `redis-cli --eval`.

---

## 6. CI/CD и автоматизация

- GitHub Actions:  
  - `lint-and-test` → запускает unit tests фронта, Rust, Python, линтеры.  
  - `integration` → docker-compose (Mongo, Redis, Qdrant, Rust, Python). Выполняет API/E2E тесты.  
  - `build` → сборка Docker images + PWA bundle.  
  - `release` → прогон regression suite (Playwright) и публикация артефактов.
- Артефакты тестов (JUnit, coverage) хранятся 30 дней.  
- Блокирующие ошибки: провал любого unit/integration/perf теста → деплой запрещён.

---

## 7. Тестовые данные и окружение

- **datasets/** — с seed-данными (темы, шаблоны, пользователи) и маскированными логами для античита.  
- для E2E используются тестовые учётки: `student1@test`, `teacher1@test`, `admin@test`.  
- docker-compose профиль `test` поднимает сервисы на портах 8081, 9000, 27017, 6379, 6333 (как в `ports.md`).  
- Для производительных тестов используется отдельный сервер (4 vCPU, 8 GB RAM) с копией данных.

---

## 8. Покрытие критических сценариев (регрессия)

### Основные сценарии

1. Прохождение уровня (без подсказок, с подсказкой, с таймаутом).  
2. Накопление серий и бонусов (проверка правил S1–S5).  
3. Аналитика учителя (просмотр статистики + экспорт).  
4. Модерация контента + обновление эмбеддингов.  
5. Античит: быстрые ответы, повторяющиеся шаблоны → уведомление и блокировка.  
6. Fallback: недоступность Qdrant/YandexGPT → выдаётся шаблонная подсказка.  
7. SSO (опционально) → вход через OAuth.  
8. Service Worker: офлайн-режим, восстановление после reconnect.

### Расширенные граничные случаи (Edge Cases)

#### 8.1 Разрыв серии и переход на новое задание

**Тест-кейс:** `edge_case::test_series_reset_and_new_level_transition`

**Сценарий:**
1. Ученик на уровне 1 получает серию из 5 верных ответов (накопил +5 +5 = +10 бонуса).
2. На 6-м задании даёт неверный ответ → серия сбрасывается на 0.
3. Переходит на уровень 2; серия должна начаться с 0.
4. На уровне 2 даёт 4 верных ответа подряд.
5. **Проверка:** На 4-м ответе уровня 2 бонус +5 начисляется (серия = 4), и это считается новой серией (не продолжением уровня 1).

**Реализация:**
- Unit test (Rust): `scoring::test_series_reset_on_level_transition`
- Integration test (E2E): `e2e::test_series_continues_on_new_level_after_reset`

---

#### 8.2 Таймаут во время ввода текста

**Тест-кейс:** `edge_case::test_timeout_during_typing`

**Сценарий:**
1. Ученик вводит текстовый ответ (тип задания = text input, таймер = 90 сек).
2. В момент 85-й секунды ученик печатает символ.
3. На 90-й секунде таймер истекает, сессия автоматически закрывается.
4. **Проверка:** Ответ не сохраняется, начисляется 0 баллов, но серия не разрывается (если была).

**Реализация:**
- Integration test: `integration::test_timeout_save_zero_score_preserve_series`
- Mock: таймер запускается на 85-й сек, проверяется callback

---

#### 8.3 Использование подсказок при недостатке баллов

**Тест-кейс:** `edge_case::test_hint_insufficient_score`

**Сценарий:**
1. Ученик прошёл задание 1 и получил +10 баллов (всего 10).
2. На задании 2 даёт неверный ответ (0 баллов). Баллы всё ещё 10.
3. Пытается использовать подсказку, которая стоит −5 баллов.
4. **Проверка:** Система вычитает 5 баллов (итого 5), выдаёт подсказку.
5. Пытается использовать подсказку 2 (−5 баллов). Баллы: 5 − 5 = 0. Подсказка выдана.
6. Пытается использовать подсказку 3. Баллы = 0. **Проверка:** Система возвращает ошибку (лимит исчерпан), баллы не меняются.

**Реализация:**
- Unit test: `scoring::test_hint_deduction_atomic_with_insufficient_score`
- Integration test: `integration::test_hint_limit_enforcement_with_score_tracking`

---

#### 8.4 Fallback на шаблоны при недоступности YandexGPT

**Тест-кейс:** `edge_case::test_explanation_yandexgpt_timeout_fallback`

**Сценарий:**
1. Ученик даёт неверный ответ и запрашивает пояснение.
2. Explanation Builder вызывает YandexGPT API.
3. YandexGPT не отвечает (timeout > 2 сек) или возвращает 503 Service Unavailable.
4. **Проверка:** Hint Service сразу возвращает предварительно подготовленный шаблон пояснения (без задержки).
5. Логируется инцидент в `incidents` collection для мониторинга.

**Реализация:**
- Unit test (Python): `explanation::test_yandexgpt_timeout_fallback_to_template`
- Integration test: `integration::test_hint_delivery_with_yandexgpt_failure`
- Mock: используется mock для YandexGPT с искусственной задержкой

---

#### 8.5 Синхронизация офлайна при reconnect

**Тест-кейс:** `edge_case::test_offline_sync_on_reconnect`

**Сценарий:**
1. PWA работает онлайн, ученик прошёл 2 задания (оба на сервере).
2. Интернет обрывается (симуляция: Service Worker кеширует ответы).
3. Ученик проходит ещё 3 задания офлайн (результаты сохраняются локально в IndexedDB).
4. Интернет восстанавливается. PWA автоматически синхронизирует 3 новых попытки с сервером.
5. **Проверка:** Все 5 попыток синхронизированы в MongoDB, баллы пересчитаны, серия пересчитана.

**Реализация:**
- E2E test (Playwright): `e2e::test_service_worker_offline_cache_and_sync`
- Mock: используется Chrome DevTools Protocol для имитации offline/online

---

#### 8.6 Тройной нажатия кнопки "Ответить" (race condition)

**Тест-кейс:** `edge_case::test_answer_submission_race_condition`

**Сценарий:**
1. Ученик быстро три раза нажимает кнопку "Ответить" (идемпотентность).
2. API Rust должен обработать все три запроса, но засчитать только один ответ.
3. **Проверка:** В `attempts` collection только одна запись для этой задачи, баллы начисляются один раз.

**Реализация:**
- Unit test: `api::test_idempotent_answer_submission`
- Integration test: `integration::test_parallel_answer_submissions`

---

#### 8.7 Древний сессионный ключ в Redis (TTL истёк)

**Тест-кейс:** `edge_case::test_expired_session_redis_ttl`

**Сценарий:**
1. Ученик открыл сессию 1 час назад. Session Manager записал в Redis `session:{id}` с TTL = 1 час.
2. Прошёл 1 час + 1 сек. Ключ в Redis истёк и удалён.
3. Ученик пытается отправить ответ на оставшееся задание.
4. **Проверка:** API возвращает 404 ("сессия не найдена"), ученик вынужден начать заново. Но данные в MongoDB сохранены (попытки).

**Реализация:**
- Integration test: `integration::test_session_expiration_redis_ttl`
- Manual test: настроить TTL в Redis на 10 сек для проверки

---

#### 8.8 Anticheat: паттерны "A B A B A B" (переменные ответы)

**Тест-кейс:** `edge_case::test_anticheat_alternating_pattern`

**Сценарий:**
1. Ученик на протяжении уровня (10 заданий MCQ) даёт ответы: вариант A, вариант B, A, B, A, B, ...
2. Вероятность такого паттерна ≈ 0.001 (случайно).
3. **Проверка:** Speed Detector обнаруживает паттерн, увеличивает счётчик `pattern_hits`.
4. При `pattern_hits` > 8 за сессию → генерирует `Incident`, вызывает CAPTCHA.

**Реализация:**
- Unit test: `anticheat::test_pattern_detector_alternating_sequence`
- Integration test: `integration::test_anticheat_incident_on_pattern`

---

#### 8.9 Anticheat: очень быстрые ответы (< 2 сек на анализ)

**Тест-кейс:** `edge_case::test_anticheat_speed_threshold`

**Сценарий:**
1. Ученик получает задание на анализ текста (сложность = high, таймер = 180 сек).
2. Отправляет ответ через 1.5 секунды.
3. **Проверка:** Speed Detector отмечает как подозрительное (`speed_hits++`).
4. При `speed_hits` > 5 за час → блокировка на 24 часа.

**Реализация:**
- Unit test: `anticheat::test_speed_detection_threshold`
- Integration test: `integration::test_anticheat_blocking_on_repeated_fast_answers`

---

#### 8.10 ОWASP: SQL/NoSQL injection в параметрах ответа

**Тест-кейс:** `security::test_nosql_injection_prevention`

**Сценарий:**
1. Ученик отправляет ответ вида: `{"$gt": null}` или `{\"$where\": \"1==1\"}`
2. **Проверка:** API парсит это как обычную строку, не как MongoDB query injection. Ответ проверяется как строка и помечается неверным.

**Реализация:**
- Fuzzing test: `cargo fuzz answer_parser` (проверяет, что JSON parses safely)
- Unit test: `security::test_malicious_json_input`

---

## 9. Метрики и целевые показатели (SLA)

| Метрика | Целевое значение | Сценарий тестирования |
|---------|---|---|
| **Latency ответа** | p95 ≤ 100 мс, p99 ≤ 200 мс | `perf::test_answer_check_latency_p95`, k6 500 rps |
| **Прохождение уровня** | p95 ≤ 5 сек (5 заданий) | `e2e::test_level_completion_latency` |
| **Генерация подсказки** | p95 ≤ 1.5 сек (с кэш), 2 сек (новая) | `perf::test_hint_generation_with_without_cache` |
| **Отчёт класса** | ≤ 5 сек (30 учеников) | `perf::test_report_generation_latency` |
| **Availability** | 99.5% в учебное время | Continuous E2E monitoring (Synthetics) |
| **Error rate** | ≤ 0.1% | Логирование всех ошибок, dashboard в Grafana |
| **Test coverage** | Unit ≥ 80%, Integration ≥ 70%, E2E ≥ 50% | `cargo tarpaulin`, `nyc` для TypeScript |

При добавлении новых фич в backlog дополняются соответствующие тест-кейсы и автоматизация.
